 In the last presentation we discussed the difference between algorithm and a program. Now in this presentation we will understand the characteristics of an algorithm which we need to understand before moving forward. So let's get started with this lecture and let's see the topics 1 by 1. The first topic of this lecture is characteristics of an algorithm. We will first understand some characteristics of an algorithm. Then after this I will give you the summary of this entire lecture so that you would be able to see all the characteristics in the same place and then finally I will give you the homework problem of this lecture which you need to solve on your own after completion of this lecture. So let's start with the characteristics of an algorithm. The first characteristic of an algorithm is input and algorithm can take 0 or more inputs. It is possible for an algorithm to receive no inputs at all or it may receive more than 1 inputs and algorithm is said to be valid in all these cases. Now let's discuss an example algorithm which takes no inputs at all. This is the algorithm. This algorithm takes no input. It generates a random number and output that random number. It is not receiving any input from the user. So this algorithm is an example algorithm with no inputs. Now let's discuss an example algorithm with more than 1 inputs precisely 2 inputs. So here is the example algorithm. This algorithm generates the result of addition of 2 numbers, number 1 and number 2 which we receive from the user. In step number 2 we are asking the user to input the first number and we are calling it number 1. In step number 3 we are asking the user to input the second number and we are calling it number 2. Then we are adding number and number 2 and finally we are outputting the result of the addition of number 1 and number 2. This algorithm is an example algorithm with 2 inputs. So with these 2 examples it is clear that an algorithm can take 0 inputs or more than 1 inputs. Now as we have understood this characteristic let's move to characteristic number 2 which is output. An algorithm must produce at least 1 output. It is important for an algorithm to produce at least 1 output. It can accept 0 inputs but it is not possible for an algorithm to generate no output. An algorithm must generate at least 1 output. It can produce more than 1 outputs but at least 1 output is mandatory. Then only we can say that the algorithm is valid. Otherwise we consider the algorithm as invalid. Now let's see the example algorithm which produces 1 output. Here is the example algorithm. We are taking the same example of generating a random number algorithm. In this algorithm we are generating a random number and we are outputting that random number. Here there is only one number that is generated. This is just one output hence we can say that this algorithm is an example algorithm with 1 output. Now let's see the example algorithm with more than 1 outputs precisely 2 outputs. Here is the example algorithm. In this algorithm we are trying to generate the result of square and cube of a number. We'll receive a number from the user. This means that we just have 1 input. In step number 2 we are asking the user to input a number and we are calling it num. And then we are calculating the square of num. We are calling it square result. Then we are calculating the cube of num. We are calling it cube result. Finally we are outputting square result and cube result. So this algorithm is an example algorithm with 2 outputs. It is possible for an algorithm to generate more than 1 outputs but at least 1 output must be there. Now let's move to characteristic number 3 which is finiteness. An algorithm must terminate in finite time. If an algorithm takes forever to run then we do not consider it as a valid algorithm. That algorithm is invalid. So in order to say that an algorithm is valid it must terminate in finite time. Let's discuss an example algorithm that runs forever. Here is the algorithm. In this algorithm we are first initializing count to 0. So there is some variable count and it is initialized to 0. Then we are entering the loop. Now within this loop we are incrementing the count by 1. And we want to repeat these steps 3 and 4. This is what is given here in step number 5. Repeat steps 3 and 4. But we are not specifying when to stop this repetition. We are just mentioning this that we need to repeat these steps but we are not mentioning when to stop. So this algorithm will run forever. We will continue to enter the loop but there is no termination criteria. So this algorithm will run forever. Now let's discuss an example algorithm which will terminate in finite time. So here is the example algorithm. We are first initializing count to 0. Then we are setting a limit for the number of counts and we are calling it let's say 10. So we are setting this limit of 10. Then we enter the loop that it rates up to the specified limit. Now within the loop we are incrementing the count by 1. And in step number 6 we are clearly specifying this that we need to repeat steps 4 and 5 until the specified limit is reached. What was the limit? The limit was 10. So we will repeat these steps 10 times. And this means that the algorithm will terminate in finite time. It will not run forever. So this algorithm is considered valid while this algorithm on the other hand is invalid. So an algorithm must follow the finiteness characteristic that is an algorithm must terminate in finite time. Now let's understand the characteristic number 4 which is definiteness. An algorithm must be clear and unambiguous. It is important for an algorithm to not have any ambiguity. Now what does this mean? This means that each and every instruction or step of an algorithm must be clear and precise. Or we can say that they must give only one meaning. There must not be multiple meanings of these steps we are writing. So an algorithm must be clear in its meaning and it must be unambiguous. This means it must not have any ambiguity. There must not be multiple meanings of the steps that we write for an algorithm. Now let's see the example algorithm which is ambiguous. That means algorithm with ambiguity. Here is the algorithm. In step number 2 we are asking for two numbers A and B. And then as mentioned in step number 3 we need to perform some operation on A and B. Here we are not clearly specifying which operation. We are just specifying some operation which is not clear and it is ambiguous. After this we are outputting the result. But the main thing is we are not specifying which operation to perform here. Hence this algorithm is considered ambiguous. On the other hand let's discuss an example of algorithm which does not have any ambiguity. So here is the example algorithm. Here we are asking for two numbers A and B and then we are calculating the sum of A and B and we are storing it in the variable sum. After this we are outputting the result of the sum. Here we are clearly specifying in step number 3 that we want to calculate the sum of A and B. Not just some operation but some. So this algorithm is an example algorithm which does not have any ambiguity. We are clearly specifying each step and each step has only one meaning. So with this I hope it is clear what is the meaning of definiteness. An algorithm must be clear and unambiguous. Let's now understand characteristic number 5 which is effectiveness. An algorithm should take less time and space to execute. It should run in less time and it should take less memory space as well. We will learn throughout this entire course how to design algorithms in the way that should take less time and less memory space. Time is a very important resource and so is the memory space. We will try to preserve them as much as possible. We will see several tools which helps us in analyzing an algorithm that tells us how effective an algorithm is. Now let's discuss an example algorithm which is less effective. This means which takes more time. Here is the example algorithm. Through this algorithm we want to calculate the sum of first n natural numbers. For this purpose we first ask a positive integer n. We want to calculate the sum of first n natural numbers. That is why we are asking for a positive integer n. Then we are initializing the variable sum to 0. After this we are entering the loop that it rates from 1 to n and inside this loop we want to add the current iteration value to sum. We want to repeat steps 4 and 5 here. These steps will be repeated until we reach value n. Finally we will output the value of sum. You can verify this on your own that this algorithm has the capability to produce the result of some of first n natural numbers. That depends upon the value of n. It can be 5, it can be 10. Try to take one example value of n and try to run this algorithm on your own and understand this how we are getting the sum of first n natural numbers. The time complexity of this algorithm is big go of n. We will learn more about time complexity but just keep this in mind that this algorithm will take big go of n time. Now let's see the example algorithm which is more effective. Here is the example algorithm. With this algorithm also we want to calculate the sum of first n natural numbers but this time we are using this formula. Sum equal to n into n plus 1 divided by 2. We are well familiar with this formula to calculate sum of first n natural numbers. This algorithm is more effective than this algorithm because the time complexity of this algorithm is big go of 1. This algorithm is much faster if we compare it with this algorithm. Now you might be wondering what is the meaning of time complexity. Don't worry we will understand time complexity in our subsequent lectures because this course is all about the design and analysis of algorithms. In the analysis part we will understand how to analyze an algorithm. This means to check how effective an algorithm is. Just remember for now that big go of n is bigger than big go of 1. This means that this algorithm takes more time compared to this algorithm. This algorithm is much faster because here we are using this formula to calculate the sum of first n natural numbers. And here we are using loops. We will understand this why it affects the time complexity in our subsequent lectures. For now just remember this that big go of n is bigger than big go of 1. Hence the time complexity of this algorithm is greater than that of this algorithm. This algorithm takes more time compared to this algorithm. So this is all we need to understand about the effectiveness and algorithm should take less time and space to execute. Our clear preference is this algorithm because this algorithm takes less time. So with this we have understood all the characteristics of an algorithm. Now let's see the entire summary of this lecture. This means all the characteristics in one place. So here is the entire summary. First characteristic is 0 or more input. This means an algorithm can accept 0 inputs or maybe more than 1 inputs. But it must generate at least one output. An algorithm must take finite amount of time and it must be unambiguous. Also an algorithm should be effective. This means we must always target to write algorithms which take less time and space. So these are all the characteristics of an algorithm which we need to keep in our minds. Now let's move to the homework problem of this lecture. Here is the homework problem. Determine what characteristic or characteristics is our missing in the following algorithm. Here is the algorithm. You need to determine what characteristic or characteristics are missing in this algorithm. It might be possible that in this algorithm more than one characteristics are missing. You need to identify this on your own. Try solving this question and post your answers in the comment section. So with this we are done with this lecture. Okay friends, this is it for now. Thank you for watching this presentation. I will see you in the next one.